## Mysql

悲观锁(排他锁和共享锁)

`SELECT ... FOR UPDATE` 和 `SELECT ... LOCK IN SHARE MODE`（通常简称为 `SELECT ... FOR SHARE`）是 MySQL 中用于控制并发访问的两种不同类型的锁。它们分别适用于不同的场景，具体取决于你希望如何管理对数据行的读取和修改。

### SELECT ... FOR UPDATE

#### 适用场景：

1. **更新前读取**:
   - 当你需要先读取某些数据，然后基于这些数据进行更新或删除操作时，应该使用 `FOR UPDATE` 来确保在事务期间没有其他事务可以修改这些数据。
   - 例如，在银行转账系统中，当你从一个账户扣款并往另一个账户存款时，你需要确保在这两个操作之间没有任何其他事务改变了这两个账户的余额。

2. **防止幻读**:
   - 如果你想避免在一个事务内看到其他事务插入的新行（即幻读），可以在查询条件上加 `FOR UPDATE` 锁。这会锁定所有符合条件的现有行以及任何可能满足条件的新插入行。

3. **排他性操作**:
   - 对于那些需要独占访问特定行的操作，比如库存管理系统中的商品数量减少，使用 `FOR UPDATE` 可以确保只有一个事务能够执行该操作，直到它完成并提交。

4. **长时间运行的事务**:
   - 在一些情况下，事务可能会持续较长时间，如复杂的业务逻辑处理。为了保护正在处理的数据不被其他事务更改，你可以使用 `FOR UPDATE` 来锁定相关行。

#### 示例：
```sql
START TRANSACTION;
SELECT * FROM accounts WHERE account_id = 123 FOR UPDATE;
-- 执行业务逻辑...
UPDATE accounts SET balance = balance - 50 WHERE account_id = 123;
COMMIT;
```

### SELECT ... FOR SHARE (LOCK IN SHARE MODE)

#### 适用场景：

1. **只读操作**:
   - 如果你只需要读取数据而不需要对其进行修改，并且希望阻止其他事务对该数据进行写入操作，那么可以使用 `FOR SHARE`。这允许多个事务同时读取相同的数据，但不允许它们修改这些数据，直到当前事务结束。

2. **防止脏读**:
   - 在多读少写的环境中，使用共享锁可以帮助避免脏读问题，即读取到未提交的数据。通过加共享锁，你可以确保读取的数据是一致的，不会受到其他事务的影响。

3. **高并发读取**:
   - 对于那些有大量并发读取请求的应用程序，使用 `FOR SHARE` 可以提高系统的整体性能，因为它允许多个事务并行读取而不相互阻塞。

4. **简化冲突检测**:
   - 在某些情况下，你可能只想检查某行是否存在并且不希望其被其他事务修改。这时可以使用 `FOR SHARE` 来快速验证这一点，而无需获取更严格的排他锁。

#### 示例：
```sql
START TRANSACTION;
SELECT * FROM products WHERE product_id = 456 LOCK IN SHARE MODE;
-- 执行业务逻辑...
COMMIT;
```

### 关键区别总结

| 特性                     | `SELECT ... FOR UPDATE`          | `SELECT ... FOR SHARE`                 |
|--------------------------|---------------------------------|----------------------------------------|
| **锁类型**               | 排他锁 (X 锁)                   | 共享锁 (S 锁)                          |
| **是否允许其他读取**     | 不允许其他事务加任何类型的锁    | 允许多个事务读取                      |
| **是否允许其他写入**     | 不允许其他事务写入              | 不允许其他事务写入                    |
| **应用场景**             | 更新前读取、防止幻读、排他性操作 | 只读操作、防止脏读、高并发读取         |
| **性能影响**             | 更多阻塞其他读取和写入事务      | 较少阻塞其他读取事务                  |

### 选择合适的锁策略

选择哪种锁取决于具体的业务需求和技术考量。正确地理解和应用这两种锁可以帮助你在高并发环境下更好地管理和优化数据库的并发性能。如果你不确定应该用哪种锁，考虑以下几点：

- **是否会后续更新？**
  - 如果会，则使用 `FOR UPDATE`。
  
- **只是读取吗？**
  - 如果是纯粹的读取，并且你不希望其他事务在此期间修改数据，那么 `FOR SHARE` 是更好的选择。

- **并发模式是什么样的？**
  - 对于读多写少的应用场景，`FOR SHARE` 可以提供更高的并发度；而对于频繁写入的情况，`FOR UPDATE` 则更为合适。

总之，理解你的应用程序的工作负载特征，并根据实际情况选择最适当的锁机制，这对于构建高效可靠的数据库应用程序至关重要。
